### 1. HashMap
* HashMap的数据结构  
哈希表表结构（数组+链表）实现，当链表长度超过8时，链表转化为红黑树。
* HashMap的工作原理  
HashMap底层是hash数组和单向链表实现，数组中每个元素都是链表，由Node的内部类（实现了Map.Entry接口）实现，通过put/get方法进行存取数据。
存储对象时，将K/V传给put方法：  
①、调用hash(k)方法计算k的hash值，然后结合数组长度，计算得出数组下标；  
②、调整数组大小（当容器中的元素大于capacity*loadfactor时，容器会扩充为原数组大小的2倍）；  
③、如果k的hash值在HashMap中不存在，则直接插入，如果k的hash值在HashMap中已经存在，且他们两者equals返回true，则更新键值对（value值被覆盖），如果k的hash值在HashMap中存在，且他们两者equals返回fasle，则插入到链表的尾部（1.7头插法，1.8尾插法）或者插入到红黑树中（树的添加方式）；  
获取对象时，将k传给get方法：  
①、调用hash(k)方法计算出k的hash值，从而计算出k在数组中的下标；  
②、遍历链表或红黑树，equals方法查找相同Node链表中K值对应的V值； 
* 当两个对象的hashcode相同会发生什么
hashcode相同，则根据hashcode计算出的数组下标就相同，会产生hash冲突；如果put数据时hash冲突则会将Node数据插入到链表或树中，如果get数据时hash冲突，则遍历链表或树通过equals方法逐个判断；
* 你知道hash方法的实现吗 为什么要这样实现 为什么要用异或运算符
先计算key的hashCode，然后对hashCode的高16位和低16位做异或运算，这样做可以让hashcode的每一位都参与运算，只要hashcode有1位发生变化，hash结果就会不同，从而获得更好的散列值，减少hash冲突；
* HashMap的table容量如何确定 loadFactor是什么 该容量如何变化 这种变化会带来什么问题
table容量通过capacity来确定，一般默认16，也可以构造map时初始化大小；loadFactor是负载因子，当容器中的元素大于capacity*loadfactor时，容器会扩充为原数组大小的2倍；数组每次扩容调用resize()方法，数组大小扩大为原来的2倍；数组扩容会耗性能，频繁的扩容会带来性能上的损耗；
* 数组扩容过程
创建一个新的数组，大小为旧数组的2倍，重新计算元素在新数组中的下标，在新数组中的下标一种是保持原下标不变，另外一种=旧数组下标+旧数组大小；
* 拉链发导致的链表过深问题为什么不用二叉树代替，而选择红黑树 为什么不一直使用红黑树
* 说说你对红黑树的见解
* jdk8中对HashMap做了哪些变动
* HashMap LinkedHashMap TreeMap有什么区别 分别对应的使用场景
* HashMap HashTable有什么区别
* Java中另一个线程安全的与HashMap极其类似的类时什么 同样是线程安全，他与HashTable在线程同步上有什么不同
* HashMap ConcurrentHashMap 有什么区别
* 为什么ConcurrentHashMap比HashTable效率要高
* ConcurrentHashMap锁机制具体分析
* ConcurrentHashMap在JDK1.8中为什么要使用内置锁synchronized来代替重入锁ReentrantLock
* ConcurrentHashMap简单介绍
* ConcurrentHashMap的并发度是什么
### 2. ArrayList与LinkedList的区别
### 3. ConcurrentHashMap原理
