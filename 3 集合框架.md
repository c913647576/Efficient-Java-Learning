### 1. HashMap
* HashMap的数据结构  
哈希表表结构（数组+链表）实现，当链表长度超过8时，链表转化为红黑树。
* HashMap的工作原理  
HashMap底层是hash数组和单向链表实现，数组中每个元素都是链表，由Node的内部类（实现了Map.Entry接口）实现，通过put/get方法进行存取数据。
存储对象时，将K/V传给put方法：  
①、调用hash(k)方法计算k的hash值，然后结合数组长度，计算得出数组下标；  
②、调整数组大小（当容器中的元素大于capacity*loadfactor时，容器会扩充为原数组大小的2倍）；  
③、如果k的hash值在HashMap中不存在，则直接插入，如果k的hash值在HashMap中已经存在，且他们两者equals返回true，则更新键值对，如果k的hash值在HashMap中存在，且他们两者equals返回fasle，则插入到链表的尾部（1.7头插法，1.8尾插法）或者插入到红黑树中（树的添加方式）；  
获取对象时，将k传给get方法：  
①、调用hash(k)方法计算出k的hash值，从而计算出k在数组中的下标；  
②、遍历链表或红黑树，equals方法查找相同Node链表中K值对应的V值； 
* 当两个对象的hashcode相同会发生什么
* 你知道hash方法的实现吗 为什么要这样实现
* 为什么要用异或运算符
* HashMap的table容量如何确定 loadFactor是什么 该容量如何变化 这种变化会带来什么问题
* HashMap中put方法的过程
* 数组扩容过程
* 拉链发导致的链表过深问题为什么不用二叉树代替，而选择红黑树 为什么不一直使用红黑树
* 说说你对红黑树的见解
* jdk8中对HashMap做了哪些变动
* HashMap LinkedHashMap TreeMap有什么区别 分别对应的使用场景
* HashMap HashTable有什么区别
* Java中另一个线程安全的与HashMap极其类似的类时什么 同样是线程安全，他与HashTable在线程同步上有什么不同
* HashMap ConcurrentHashMap 有什么区别
* 为什么ConcurrentHashMap比HashTable效率要高
* ConcurrentHashMap锁机制具体分析
* ConcurrentHashMap在JDK1.8中为什么要使用内置锁synchronized来代替重入锁ReentrantLock
* ConcurrentHashMap简单介绍
* ConcurrentHashMap的并发度是什么
### 2. ArrayList与LinkedList的区别
### 3. ConcurrentHashMap原理
